 _DJ_←{
     ⍝ Deutsch–Jozsa algorithm.
     ⍝ Takes a vector state in the 0 state (all qubits are in the 0 states).
     ⍝ Applies the algorithm with the passed oracle and returns the vector state without being measured.
     ⍝
     ⍝ Whenever the idiom {⍵:X ⋄ Y}Bs appears, The function is checking if the ancilla qubit is 0 to not apply any SWAPs
     ⍝
     ⍝ ⍵[1]: Index of the ancilla qubit, if this is not passed (meaning that ⍵ is simply the vector state) the ancilla qubit will be 0
     ⍝ ⍵[2]: Initial vector state in the 0 state.
     ⍝ ⍺⍺: Oracle to be used in the DJ algorithm.

     ⍝ Define the functions that we are going to use
     X←#.quapl.gates.X
     H←#.quapl.gates.H
     CNOT←#.quapl.gates.CNOT
     SWAP←#.quapl.gates.SWAP
     stage←#.quapl.circuit.stage
     w←⍵

     X_anc←{
         ⍝ Apply an X gate to the ⍺ index

         ((⍺)(⊂X))stage(⊃⍵)
     }

     swap_anc←{
         ⍝ ⍵: Vector state to apply X and SWAP to the ancilla qubit
         ⍝ ⍺: Index of the ancilla qubit
         ⍝ Input variables are placed in defined variables to make scopes clear.


         w_int←⍵
         a←⍺
         mid_state←⍺ X_anc ⍵
         {⍵:((0 a)(⊂SWAP)stage mid_state) ⋄ w_int}(⍺≠0)
     }

     unswap_anc←{
         ⍝ ⍵: Vector state to undo swap_anc apply X and SWAP to the ancilla qubit
         ⍝ ⍺: Index of the ancilla qubit
         ⍝ Input variables are placed in defined variables to make scopes clear.

         w_int←⍵
         a←⍺
         mid_state←0 X_anc(⊂⍵)
         {⍵:((0 a)(⊂SWAP)stage mid_state) ⋄ w_int}(⍺≠0)
     }

     ⍝ Preps the state according the ancilla qubit.
     ini←({⍵:((0 X_anc(⊂w))) ⋄ ((w[1]swap_anc w[2]))}((|≡⍵)≠2))
     n_qubits←(2⍟1⌷⍴ini)

     stg_ctrl←(((⍳n_qubits)-1)({H}¨⍳n_qubits))

     ⍝ Create the superposition for the oracle
     mid_state←stg_ctrl stage ini

     ⍝ pass to the oracle
     oracle_state←⍺⍺ mid_state
     final_state←stg_ctrl stage oracle_state

     ⍝ Unprep the state
     {⍵:((0 X_anc(⊂final_state))) ⋄ ((w[1]unswap_anc final_state))}((|≡⍵)≠2)
 }
