â Santiago Nunez-Corrales (nunezco2@illinois.edu)
â National Center for Supercomputing Applications
â University of Illinois Urbana-Champaign

â The namespace `quapl` provides all required definitions to implement a
â mathematica simulation of a quantum computing device.

    
â Single qubit manipulations
:Namespace sng
    â Ground state |0>
    q0 â† 2 1 â´ 1 0

    â Excited state |1>
    q1 â† 2 1 â´ 0 1

    â Linear superposition of amplitudes
    qx â† { #.quapl.mlt.normalize âŠƒ+/(q0 q1) Ã—.+ âµ }

    â Bloch state
    bloch â† { (2 â—‹ (âµÃ·2)), (*(0J1Ã—âº))Ã—(1 â—‹ (âµÃ·2)) }

    â Projection operator to 0
    P0 â† 2 2 â´ 1 0 0 0

    â Projection operator to 1
    P1 â† 2 2 â´ 0 0 0 1

:EndNamespace

â Multiqubit manipulations
:Namespace mlt

    â Normalize a quantum state
    normalize â† {âµÃ·0.5*â¨(dagger+.Ã—âŠ¢)âµ}

    â Test that we have a valid qubit
    valid â† {
        ((â´âµ)[1]=1)âˆ§(âŠƒ(2âŸ(â´âµ)[2])=âŒˆ2âŸ(â´âµ)[2]): 1    â We have a bra
        ((â´âµ)[2]=1)âˆ§(âŠƒ(2âŸ(â´âµ)[1])=âŒˆ2âŸ(â´âµ)[1]): 1    â We have a ket
        â 0                                         â Not a qubit
    }

    â Kronecker product
    kpr â† âŠƒ (,/ (âªâŒ¿ (âŠ‚[3 4] âˆ˜.Ã—)))

    â Separate a vector state into a list of lists corresponding to 
    separateâ†{
        2=â´âµ: âŠ‚âµ
        mask â† 1=(2*(2âŸâ´âµ)-1)|â³â´âµ
        partition â† maskâŠ‚âµ
        lcd_a â† âˆ¨/âŠƒ1âŒ·partition
        lcd_b â† âˆ¨/âŠƒ2âŒ·partition
        0=lcd_a: (âŠ‚0 1),(âˆ‡âŠƒ2âŒ·partition)
        0=lcd_b: (âŠ‚1 0),(âˆ‡âŠƒ1âŒ·partition)
        a â† (âŠƒ1âŒ·partition)Ã·lcd_a
        b â† (âŠƒ2âŒ·partition)Ã·lcd_b
        aâ‰¡b: (âŠ‚lcd_a lcd_b),(âˆ‡ a)
        âŠ‚âµ
    }
    
    â Undo Kronecker product naively for vector states
    unkpr â† {
        vs_list â† ,âµ
        flat_qubits â† separate vs_list
        num_qs â† âŠƒâ´flat_qubits
        num_qs 1â´(2 1)âˆ˜â´Â¨ normalizeÂ¨ flat_qubits
    }

    â Dagger operator
    dagger â† { â‰+âµ }

    â Transform to ket
    ket â† {
        (â´âµ)[2]=1: âµ   â return same object if ket is column vector
        dagger âµ         â else return transposed conjugate
    }

    â Transform to bra
    bra â† {
        (â´âµ)[1]=1: âµ   â return same object if bra is row vector
        dagger âµ         â else return transposed conjugate
    }

    â Measures a vector state
    â
    â âµ: vector state to measure
    â âº: indices of qubits to measure, if left empty all of the qubits will be measured
    â
    â Returns a pair of items:
    â - An array of tuples where the first item of the tuple is the index of the qubit measured and the second item,
    â    the measured state.
    â - The final vector state 
    measure â† {
        n_qubits â† (2âŸ1â†‘(â´âµ))
        idxs â† â³(1â†‘â´âµ)
        âº â† (â³n_qubits)-1
        binary_basis â† #.quapl.circuit.tnsidx n_qubits
        q_levels â† #.quapl.sng.q0 #.quapl.sng.q1

        measure_helper â† {
            âºâ‰¡â¬: âµ
            idx â† (1â†‘âº) + 1
            past_results vs â† âµ
            select â† idxâŒ·[2]binary_basis

            basis_0_idx â† (~select)/idxs
            basis_1_idx â† select/idxs
            split_idx â† basis_0_idx basis_1_idx

            excited â† +/[1]((select/[1]vs)*2)
            ground â† +/[1](((~select)/[1]vs)*2)
            choice â† {+/(?0)>+\âµ}(ground excited)
            vs[(âŠƒsplit_idx[1+~choice]);] â† 0
            vs â† #.quapl.mlt.normalize vs
            past_resultsâ‰¡â¬:(1â†“âº)âˆ‡((âŠ‚((idx-1),q_levels[1+choice]))vs)
            ((1â†“âº))âˆ‡((past_results,(âŠ‚((idx-1),q_levels[1+choice])))vs)
        }

        ret â† âº measure_helper(â¬ âµ)
        (âªâŠƒret[1])(âŠƒ(ret[2]))
    }

:EndNamespace

â Quantum gates
:Namespace gates

    â Identity - nop
    I â† 2 2 â´ 1 0 0 1

    â Global phase
    G â† {IÃ—*0J1Ã—âµ}

    â X (not)
    X â† 2 2 â´ 0 1 1 0

    â Y
    Y â† 2 2 â´ 0 0JÂ¯1 0J1 0

    â Z (phase flip)
    Z â† 2 2 â´ 1 0 0 Â¯1

    â S (âˆšZ)
    S â† 2 2 â´ 1 0 0 0J1

    â V (âˆšX)
    V â† (Ã·2)Ã—(2 2 â´ 1J1 1JÂ¯1 1JÂ¯1 1J1)

    â H (Hadamard-Walsh)
    H â† (Ã·2*0.5)Ã—(2 2 â´ 1 1 1 Â¯1)

    â P (phase shift)
    P â† {
        ph â† *0J1Ã—âµ
        2 2 â´ ((1 0 0),ph)
    }

    â T (4-th root of Z)
    T â† 2 2 â´ ((1 0 0),*0J1Ã—0.25Ã—â—‹1)

    â Rx (rotation in x)
    Rx â† {
        aâ†2â—‹âµÃ·2
        bâ†0JÂ¯1Ã—1â—‹âµÃ·2
        2 2 â´ a b b a
    }

    â Ry (rotation in y)
    Ry â† {
        a â† 2â—‹âµÃ·2
        b â† 1â—‹âµÃ·2
        bm â† Â¯1Ã—b
        2 2 â´ a bm b a
    }

    â Rz (rotation in z)
    Rz â† {
        am â† *0JÂ¯1Ã—âµÃ·2
        ap â† *0J1Ã—âµÃ·2
        2 2 â´ am 0 0 ap
    }

    â U (generalized rotation)
    U â† {
        (th ph lm) â† âµ
        a â† 2â—‹thÃ·2
        b â† Â¯1Ã—(*0JÂ¯1Ã—lm)Ã—1â—‹thÃ·2
        c â† (*0JÂ¯1Ã—lm)Ã—1â—‹thÃ·2
        d â† (*0J1Ã—(ph + lm))Ã—a
        2 2 â´ a b c d
    }

    â CX (CNOT)
    CNOT â† 4 4 â´ 1 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0

    â Square root of NOT
    sqNOT â† (Ã·2)Ã—(2 2 â´ 1J1 1JÂ¯1 1JÂ¯1 1J1)

    â XNOR
    XNOR â† 4 4 â´ 0 1 0 0 1 0 0 0 0 0 1 0 0 0 0 1

    â CY
    CY â† 4 4 â´ 1 0 0 0 0 1 0 0 0 0 0 0JÂ¯1 0 0 0J1 

    â CZ
    CZ â† 4 4 â´ 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 Â¯1

    â CP (controlled phase)
    CP â† {
        ph â† *0J1Ã—âµ
        4 4 â´ 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 ph
    }

    â CS (controlled phase S)
    CS â† { 4 4 â´ 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0J1 }

    â XX (XX interaction)
    XX â† {
        x â† 2â—‹âµÃ·2
        y â† 0JÂ¯1Ã—1â—‹âµÃ·2
        4 4 â´ x 0 0 y 0 x y 0 0 y x 0 y 0 0 x
    }

    â YY (YY interaction)
    YY â† {
        x â† 2â—‹âµÃ·2
        yb â† 1â—‹âµÃ·2
        yp â† 0J1Ã—yb
        ym â† 0JÂ¯1Ã—yb
        4 4 â´ x 0 0 yp 0 x ym 0 0 ym x 0 yp 0 0 x
    }

    â ZZ (ZZ interaction)
    ZZ â† {
        xm â† *0JÂ¯1Ã—âµÃ·2
        xp â† *0J1Ã—âµÃ·2
        4 4 â´ xm 0 0 0 0 xp 0 0 0 0 xp 0 0 0 0 xm
    }

    â XY (XX + YY interaction)
    XY â† {
        x â† 2â—‹âµÃ·2
        y â† 0JÂ¯1Ã—1â—‹âµÃ·2
        4 4 â´ 1 0 0 0 0 x y 0 0 y x 0 0 0 0 1
    }

    â DCNOT (double-controlled CNOT)
    DCNOT â† 4 4 â´ 1 0 0 0 0 0 1 0 0 0 0 1 0 1 0 0
    
    â SWAP
    SWAP â† 4 4 â´ 1 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1

    â Imaginary SWAP
    iSWAP â† 4 4 â´ 1 0 0 0 0 0 0J1 0 0 0J1 0 0 0 0 0 1

    â Fermionic SWAP
    fSWAP â† 4 4 â´ 1 0 0 0 0 0 1 0 0 1 0 0 0 0 0 Â¯1

    â Square root SWAP
    sqSWAP â† 4 4 â´ 1 0 0 0 0 ((1+0J1)Ã—Ã·2) ((1-0J1)Ã—Ã·2) 0 0 ((1-0J1)Ã—Ã·2) ((1+0J1)Ã—Ã·2) 0 0 0 1

    â Square root imaginary SWAP
    sqiSWAP â† 4 4 â´ 1 0 0 0 0 (1Ã·2*0.5) (0J1Ã·2*0.5) 0 0 (0J1Ã·2*0.5) (1Ã·2*0.5) 0 0 0 0 1

    â SWAP raised to the a-th power
    aSWAP â† {
        xp â† 2Ã·â¨(1+*0J1Ã—â—‹1Ã—âµ)
        xm â† 2Ã·â¨(1-*0J1Ã—â—‹1Ã—âµ)
        4 4 â´ 1 0 0 0 0 xp xm 0 0 xm xp 0 0 0 0 1
    }

    â Fredkin (Controlled SWAP)
    FRK â† 8 8 â´ 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1

    â Toffoli (Doubly-controlled not)
    TOF â† 8 8 â´ 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0

    â Generalized controlled gate with k-qubit controls
    â âº: number of (preceding) control qubits
    â âµ: gate
    gCTR â† {
        (n _) â† â´ âµ
        ID â† {âµ âµ Ï 1, âµÏ0}
        gate â† ID 2*(âº + 2âŸn)
        ((-â´âµ)â†‘gate) â† âµ
        gate
    }

:EndNamespace

â Circuit assembly
:Namespace circuit
    
    â New ground state register
    reg â† {(âµ 1â´(â³âµ)-1),(âµ 1â´âŠ‚#.quapl.sng.q0)}

    â Obtain a subregister using qubit indices
    subregister â† {
        âˆ§/(âº âˆŠ âµ[;1])=0: â¬    â No outcome when indices are incorrect
        (âº+1)âŒ·â¨âˆ˜âŠ‚â¨âµ         â Otherwise, perform a standard selection
    }

    â Thread a set of Hilbert space entities into a larger Hilbert space entity
    thread â† âŠƒ { #.quapl.mlt.kpr/âµ }

    â Thread a (filtered) register into a vector state
    thread_reg â† {
        âŠƒ #.quapl.mlt.kpr/âµ[;2]
    }

    â Thread a gate set into a single operation
    thread_gate â† {
        âŠƒ #.quapl.mlt.kpr/âµ
    }

    â Unthread a vector state and produce a new register
    unthread_vs â† {
        num_qs â† 1âŒ·2âŸâ´âµ
        (num_qs 1 â´ (â³ num_qs)-1),(#.quapl.mlt.unkpr âµ)
    }

    â Compute the permutation p required to re-assemble a circuit stage based on a register
    â NaÃ¯ve implementation.
    â 
    â We benefit from the property relating permutations to binary represetations and how
    â it manifests into concrete permutations of qubits when re-arranging circuits, after
    â translation into a vector state.

    â Build a table with the full binary representation of (2^n, 1) indices of an C^n vector
    tnsidx â† {â‰(âµ â´ 2) âŠ¤ ((2*âµ) â´ (â³(2*âµ)) - 1)}

    â Map a qubit reordering into the tensor product row reordering
    qrdtotrd â† {1 + 2âŠ¥â‰âµâŒ·[2]â¨âˆ˜âŠ‚â¨tnsidx âº}

    â Apply a stage to a current vector state representing n qubits, with the given gates and
    â a stated gate-dependent reordering (reordering a C^2 vector is less expensive than the gates)
    â
    â âº[1]: The index of the qubits in which the gates are applied 
    â âº[2]: The set of gates to apply to those qubits
    â âµ: the target vector state
    stageâ†{
        idx gtx â† âº
        n_qubits â† (2âŸ1â†‘(â´âµ))
        qubits â† (â³(2âŸ1â†‘(â´âµ)))-1

        â Compute missing ids and identity gates
        midx â† (~(qubitsâˆŠidx))/qubits
        ids â† {#.quapl.gates.I}Â¨midx
        new_idx â† idx,midx
        new_gtx â† gtx,ids

        â Obtain the resulting permutation for the qubit reordering
        new_index â† n_qubits #.quapl.circuit.qrdtotrd (new_idx + 1)
        
        â Compute gate to apply
        com_gate â† âŠƒ#.quapl.mlt.kpr/new_gtx

        â Apply the gate and return vector state with restored order
        base â† ((â´ new_index),1) â´ 0
        base[new_index;] â† âµ[;1]
        ret â† com_gate +.Ã— base
        ret[new_index;]
    }

:EndNamespace

:Namespace show
    â Represent a single qubit
    q â† {
        #.quapl.sng.q0â‰¡âµ: '|0âŸ©'
        #.quapl.sng.q1â‰¡âµ: '|1âŸ©'
        (â•âµ[1;1]),'|0âŸ©+',(â•âµ[2;1]),'|1âŸ©'
    }

    b â† {
        #.quapl.sng.q0â‰¡âµ: '0'
        #.quapl.sng.q1â‰¡âµ: '1'
        'ğœ‘'
    }

    â Represent a register without expanding superposition or entanglement
    r â† {
        '|',(bÂ¨âŒ½âµ[;2]),'âŸ©'
    }

    â Represent in-register qubits
    r_in â† {
        rep â† âµ
        rep[;2] â† qÂ¨ âµ[;2]
        rep
    }
    
:EndNamespace
