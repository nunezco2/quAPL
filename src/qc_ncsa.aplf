â Santiago Nunez-Corrales (nunezco2@illinois.edu)
â National Center for Supercomputing Applications
â University of Illinois Urbana-Champaign

â The namespace `quapl` provides all required definitions to implement a
â mathematica simulation of a quantum computing device.

:Namespace quapl
    
    â Single qubit manipulations
    :Namespace sng
        â Ground state |0>
        q0 â† 2 1 â´ 1 0

        â Excited state |1>
        q1 â† 2 1 â´ 0 1

        â Linear superposition of amplitudes
        qx â† { #.quapl.mlt.normalize âŠƒ+/(q0 q1) Ã—.+ âµ }

        â Bloch state
        bloch â† { (2 â—‹ (âµÃ·2)), (*(0J1Ã—âº))Ã—(1 â—‹ (âµÃ·2)) }

        â Projection operator to 0
        P0 â† 2 2 â´ 1 0 0 0

        â Projection operator to 1
        P1 â† 2 2 â´ 0 0 0 1

    :EndNamespace

    â Multiqubit manipulations
    :Namespace mlt

        â Normalize a quantum state
        normalize â† {âµÃ·0.5*â¨(dagger+.Ã—âŠ¢)âµ}

        â Test that we have a valid qubit
        valid â† {
            ((â´âµ)[1]=1)âˆ§(âŠƒ(2âŸ(â´âµ)[2])=âŒˆ2âŸ(â´âµ)[2]): 1    â We have a bra
            ((â´âµ)[2]=1)âˆ§(âŠƒ(2âŸ(â´âµ)[1])=âŒˆ2âŸ(â´âµ)[1]): 1    â We have a ket
            â 0                                         â Not a qubit
        }

        â Kronecker product
        kpr â† âŠƒ (,/ (âªâŒ¿ (âŠ‚[3 4] âˆ˜.Ã—)))

        â Separate a vector state into a list of lists corresponding to 
        separateâ†{
            2=â´âµ: âŠ‚âµ
            mask â† 1=(2*(2âŸâ´âµ)-1)|â³â´âµ
            partition â† maskâŠ‚âµ
            lcd_a â† âˆ¨/âŠƒ1âŒ·partition
            lcd_b â† âˆ¨/âŠƒ2âŒ·partition
            0=lcd_a: (âŠ‚0 1),(âˆ‡âŠƒ2âŒ·partition)
            0=lcd_b: (âŠ‚1 0),(âˆ‡âŠƒ1âŒ·partition)
            a â† (âŠƒ1âŒ·partition)Ã·lcd_a
            b â† (âŠƒ2âŒ·partition)Ã·lcd_b
            aâ‰¡b: (âŠ‚lcd_a lcd_b),(âˆ‡ a)
            âŠ‚âµ
        }
        
        â Undo Kronecker product naively for vector states
        unkpr â† {
            vs_list â† ,âµ
            flat_qubits â† separate vs_list
            num_qs â† âŠƒâ´flat_qubits
            num_qs 1â´(2 1)âˆ˜â´Â¨ normalizeÂ¨ flat_qubits
        }

        â Dagger operator
        dagger â† { â‰+âµ }

        â Transform to ket
        ket â† {
            (â´âµ)[2]=1: âµ   â return same object if ket is column vector
            dagger âµ         â else return transposed conjugate
        }

        â Transform to bra
        bra â† {
            (â´âµ)[1]=1: âµ   â return same object if bra is row vector
            dagger âµ         â else return transposed conjugate
        }

        â Measures a vector state
        â
        â âµ: vector state to measure
        â âº: indices of qubits to measure, if left empty all of the qubits will be measured
        â
        â Returns a pair of items:
        â - An array of tuples where the first item of the tuple is the index of the qubit measured and the second item,
        â    the measured state.
        â - The final vector state 
        measure â† {
            n_qubits â† (2âŸ1â†‘(â´âµ))
            idxs â† â³(1â†‘â´âµ)
            âº â† (â³n_qubits)-1
            binary_basis â† #.quapl.circuit.tnsidx n_qubits
            q_levels â† #.quapl.sng.q0 #.quapl.sng.q1

            measure_helper â† {
                âºâ‰¡â¬: âµ
                idx â† (1â†‘âº) + 1
                past_results vs â† âµ
                select â† idxâŒ·[2]binary_basis

                basis_0_idx â† (~select)/idxs
                basis_1_idx â† select/idxs
                split_idx â† basis_0_idx basis_1_idx

                excited â† +/[1]((select/[1]vs)*2)
                ground â† +/[1](((~select)/[1]vs)*2)
                choice â† {+/(?0)>+\âµ}(ground excited)
                vs[(âŠƒsplit_idx[1+~choice]);] â† 0
                vs â† #.quapl.mlt.normalize vs
                past_resultsâ‰¡â¬:(1â†“âº)âˆ‡((âŠ‚((idx-1),q_levels[1+choice]))vs)
                ((1â†“âº))âˆ‡((past_results,(âŠ‚((idx-1),q_levels[1+choice])))vs)
            }

            ret â† âº measure_helper(â¬ âµ)
            (âªâŠƒret[1])(âŠƒ(ret[2]))
        }

    :EndNamespace
    
    â Quantum gates
    :Namespace gates

        â Identity - nop
        I â† 2 2 â´ 1 0 0 1

        â Global phase
        G â† {IÃ—*0J1Ã—âµ}

        â X (not)
        X â† 2 2 â´ 0 1 1 0

        â Y
        Y â† 2 2 â´ 0 0JÂ¯1 0J1 0

        â Z (phase flip)
        Z â† 2 2 â´ 1 0 0 Â¯1

        â S (âˆšZ)
        S â† 2 2 â´ 1 0 0 0J1

        â V (âˆšX)
        V â† (Ã·2)Ã—(2 2 â´ 1J1 1JÂ¯1 1JÂ¯1 1J1)

        â H (Hadamard-Walsh)
        H â† (Ã·2*0.5)Ã—(2 2 â´ 1 1 1 Â¯1)

        â P (phase shift)
        P â† {2 2 â´ ((1 0 0),(*(0J1Ã—âµ)))}

        â T (4-th root of Z)
        T â† 2 2 â´ ((1 0 0),(*(0J1Ã—(0.25Ã—â—‹1))))

        â Rx (rotation in x)
        Rx â† {2 2 â´ ((2â—‹âµÃ·2),(0JÂ¯1Ã—(1â—‹âµÃ·2)),(0JÂ¯1Ã—(1â—‹âµÃ·2)),(2â—‹âµÃ·2))}

        â Ry (rotation in y)
        Ry â† {2 2 â´ ((2â—‹âµÃ·2),(Â¯1Ã—(1â—‹âµÃ·2)),(1â—‹âµÃ·2),(2â—‹âµÃ·2))}

        â Rz (rotation in z)
        Rz â† {2 2 â´ ((*Â¯0J1Ã—(âµÃ·2)),0,0,(*0J1Ã—(âµÃ·2)))}

        â U (generalized rotation)
        U â† { 2 2 â´ (2â—‹(âµ[1]Ã·2)) (-(*0JÂ¯1Ã—âµ[3])Ã—(1â—‹(âµ[1]Ã·2))) ((*0JÂ¯1Ã—âµ[2])Ã—(1â—‹(âµ[1]Ã·2))) ((*0J1Ã—(âµ[2] + âµ[3]))Ã—(2â—‹(âµ[1]Ã·2)))}

        â CX (CNOT)
        CNOT â† 4 4 â´ 1 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0

        â XNOR
        XNOR â† 4 4 â´ 0 1 0 0 1 0 0 0 0 0 1 0 0 0 0 1

        â CY
        CY â† 4 4 â´ 1 0 0 0 0 1 0 0 0 0 0 0JÂ¯1 0 0 0J1 

        â CZ
        CZ â† 4 4 â´ 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 Â¯1

        â CP (controlled phase)
        CP â† { 4 4 â´ 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 (*0J1Ã—âµ) }

        â CS (controlled phase S)
        CS â† { 4 4 â´ 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0J1 }

        â XX (XX interaction)
        XX â† { 4 4 â´ (2â—‹(âµÃ·2)) 0 0 (0JÂ¯1Ã—(1â—‹(âµÃ·2))) 0 (2â—‹(âµÃ·2)) (0JÂ¯1Ã—(1â—‹(âµÃ·2))) 0 0 (0JÂ¯1Ã—(1â—‹(âµÃ·2))) (2â—‹(âµÃ·2)) 0 (0JÂ¯1Ã—(1â—‹(âµÃ·2))) 0 0 (2â—‹(âµÃ·2))}

        â YY (YY interaction)
        YY â† { 4 4 â´ (2â—‹(âµÃ·2)) 0 0 (0J1Ã—(1â—‹(âµÃ·2))) 0 (2â—‹(âµÃ·2)) (0JÂ¯1Ã—(1â—‹(âµÃ·2))) 0 0 (0JÂ¯1Ã—(1â—‹(âµÃ·2))) (2â—‹(âµÃ·2)) 0 (0J1Ã—(1â—‹(âµÃ·2))) 0 0 (2â—‹(âµÃ·2))}

        â ZZ (ZZ interaction)
        ZZ â† {4 4 â´ (*(0JÂ¯1Ã—(âµÃ·2))) 0 0 0 0 (*(0J1Ã—(âµÃ·2))) 0 0 0 0 (*(0J1Ã—(âµÃ·2))) 0 0 0 0 (*(0JÂ¯1Ã—(âµÃ·2)))}

        â XY (XX + YY interaction)
        XY â† { 4 4 â´ 1 0 0 0 0 (2â—‹(âµÃ·2)) (0JÂ¯1Ã—(1â—‹(âµÃ·2))) 0 0 (0JÂ¯1Ã—(1â—‹(âµÃ·2))) (2â—‹(âµÃ·2)) 0 0 0 0 1}

        â DCNOT (double-controlled CNOT)
        DCNOT â† 4 4 â´ 1 0 0 0 0 0 1 0 0 0 0 1 0 1 0 0
        
        â SWAP
        SWAP â† 4 4 â´ 1 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1

        â Imaginary SWAP
        iSWAP â† 4 4 â´ 1 0 0 0 0 0 0J1 0 0 0J1 0 0 0 0 0 1

        â Fermionic SWAP
        fSWAP â† 4 4 â´ 1 0 0 0 0 0 1 0 0 1 0 0 0 0 0 Â¯1

        â Square root SWAP
        sqSWAP â† 4 4 â´ 1 0 0 0 0 ((1 + 0J1)Ã—Ã·2) ((1 - 0J1)Ã—Ã·2) 0 0 ((1 - 0J1)Ã—Ã·2) ((1 + 0J1)Ã—Ã·2) 0 0 0 1

        â Square root imaginary SWAP
        sqiSWAP â† 4 4 â´ 1 0 0 0 0 (1Ã·2*0.5) (0J1Ã·2*0.5) 0 0 (0J1Ã·2*0.5) (1Ã·2*0.5) 0 0 0 0 1

        â SWAP raised to the a-th power
        aSWAP â† { 4 4 â´ 1 0 0 0 0 (2Ã·â¨(1+(*0J1Ã—â—‹1Ã—âµ))) (2Ã·â¨(1-(*0J1Ã—â—‹1Ã—âµ))) 0 0 (2Ã·â¨(1-(*0J1Ã—â—‹1Ã—âµ))) (2Ã·â¨(1+(*0J1Ã—â—‹1Ã—âµ))) 0 0 0 0 1}

        â Fredkin (Controlled SWAP)
        FRK â† 8 8 â´ 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1

        â Toffoli (Doubly-controlled not)
        TOF â† 8 8 â´ 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0

        â Generalized controlled gate with k-qubit controls
        â âº: number of (preceding) control qubits
        â âµ: gate
        gCTR â† {
            (n _) â† â´ âµ
            ID â† {âµ âµ Ï 1, âµÏ0}
            gate â† ID 2*(âº + 2âŸn)
            ((-â´âµ)â†‘gate) â† âµ
            gate
        }

    :EndNamespace

    â Circuit assembly
    :Namespace circuit
        
        â New ground state register
        reg â† {(âµ 1â´(â³âµ)-1),(âµ 1â´âŠ‚#.quapl.sng.q0)}

        â Filter part of the register using qubit indices
        filter â† {
            âˆ§/(âº âˆŠ âµ[;1])=0: â¬    â No outcome when indices are incorrect
            (âº+1)âŒ·â¨âˆ˜âŠ‚â¨âµ         â Otherwise, perform a standard selection
        }

        â Thread a set of Hilbert space entities into a larger Hilbert space entity
        thread â† âŠƒ { #.quapl.mlt.kpr/âµ }

        â Thread a (filtered) register into a vector state
        thread_reg â† {
            âŠƒ #.quapl.mlt.kpr/âµ[;2]
        }

        â Thread a gate set into a single operation
        thread_gate â† {
            âŠƒ #.quapl.mlt.kpr/âµ
        }

        â Unthread a vector state and produce a new register
        unthread_vs â† {
            num_qs â† 1âŒ·2âŸâ´âµ
            (num_qs 1 â´ (â³ num_qs)-1),(#.quapl.mlt.unkpr âµ)
        }

        â Compute the permutation p required to re-assemble a circuit stage based on a register
        â NaÃ¯ve implementation.
        â 
        â We benefit from the property relating permutations to binary represetations and how
        â it manifests into concrete permutations of qubits when re-arranging circuits, after
        â translation into a vector state.

        â Build a table with the full binary representation of (2^n, 1) indices of an C^n vector
        tnsidx â† {â‰(âµ â´ 2) âŠ¤ ((2*âµ) â´ (â³(2*âµ)) - 1)}

        â Map a qubit reordering into the tensor product row reordering
        qrdtotrd â† {1 + 2âŠ¥â‰âµâŒ·[2]â¨âˆ˜âŠ‚â¨tnsidx âº}

        â Apply a stage to a current vector state representing n qubits, with the given gates and
        â a stated gate-dependent reordering (reordering a C^2 vector is less expensive than the gates)
        â
        â âº[1]: The index of the qubits in which the gates are applied 
        â âº[2]: The set of gates to apply to those qubits
        â âµ: the target vector state
        stageâ†{
            idx gtx â† âº
            n_qubits â† (2âŸ1â†‘(â´âµ))
            qubits â† (â³(2âŸ1â†‘(â´âµ)))-1

            â Compute missing ids and identity gates
            midx â† (~(qubitsâˆŠidx))/qubits
            ids â† {#.quapl.gates.I}Â¨midx
            new_idx â† idx,midx
            new_gtx â† gtx,ids

            â Obtain the resulting permutation for the qubit reordering
            new_index â† n_qubits #.quapl.circuit.qrdtotrd (new_idx + 1)
            
            â Compute gate to apply
            com_gate â† âŠƒ#.quapl.mlt.kpr/new_gtx

            â Apply the gate and return vector state with restored order
            base â† ((â´ new_index),1) â´ 0
            base[new_index;] â† âµ[;1]
            ret â† com_gate +.Ã— base
            ret[new_index;]
        }

        â Compute the permutation p required to re-assemble a circuit stage based on a register
        â Intelligent tensor decomposition implementation.

        â Unthread a vector state into a (filtered) register - TODO
        â This requires solving the Nearest Kronecker Product problem
        â References:
        â - Van Loan, C.F. and Pitsianis, N., 1993. Approximation with Kronecker products (pp. 293-314). 
        â   Springer Netherlands.
        unthread_reg â† {

        }

    :EndNamespace

    :Namespace show
        â Represent a single qubit
        q â† {
            #.quapl.sng.q0â‰¡âµ: '|0âŸ©'
            #.quapl.sng.q1â‰¡âµ: '|1âŸ©'
            (â•âµ[1;1]),'|0âŸ©+',(â•âµ[2;1]),'|1âŸ©'
        }

        b â† {
            #.quapl.sng.q0â‰¡âµ: '0'
            #.quapl.sng.q1â‰¡âµ: '1'
            'ğœ‘'
        }

        â Represent a register without expanding superposition or entanglement
        r â† {
            '|',(bÂ¨âŒ½âµ[;2]),'âŸ©'
        }

        â Represent in-register qubits
        r_in â† {
            rep â† âµ
            rep[;2] â† qÂ¨ âµ[;2]
            rep
        }
        
    :EndNamespace
:EndNamespace